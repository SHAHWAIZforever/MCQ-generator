<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MCQ Quiz 100 Batch, show 20 each click</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  button { margin: 5px; padding: 10px 15px; font-size: 16px; cursor: pointer; }
  .question-block { margin-bottom: 25px; padding-bottom: 10px; border-bottom: 1px solid #ddd; }
  .question-text { font-weight: bold; font-size: 18px; margin-bottom: 8px; }
  .options { margin-left: 20px; margin-bottom: 6px; }
  .option { margin: 3px 0; }
  .correct-answer { color: green; font-weight: bold; }
</style>
</head>
<body>

<h2>Select a topic:</h2>
<button id="webdev-btn">Web Development</button>
<button id="cloud-btn">Cloud Computing</button>
<button id="cyber-btn">Cyber Security</button>

<div id="quiz-area"></div>

<script>
function decodeHtml(html) {
  const txt = document.createElement('textarea');
  txt.innerHTML = html;
  return txt.value;
}

const topicToCategory = {
  webdev: 18,
  cloud: 18,
  cyber: 18
};

// Store 100 questions per topic, initially empty
const questionsBatch = {
  webdev: [],
  cloud: [],
  cyber: []
};

// To keep track of shown question indexes to avoid repeats
const shownIndexes = {
  webdev: new Set(),
  cloud: new Set(),
  cyber: new Set()
};

// Fetch 100 questions silently, no UI change
async function fetch100Questions(topic) {
  if (questionsBatch[topic].length >= 100) return; // Already fetched

  try {
    const amount = 100;
    const category = topicToCategory[topic];
    const url = `https://opentdb.com/api.php?amount=${amount}&category=${category}&type=multiple`;
    const response = await fetch(url);
    const data = await response.json();

    if (data.response_code === 0 && data.results.length) {
      questionsBatch[topic] = data.results.map(q => {
        const question = decodeHtml(q.question);
        const correct_answer = decodeHtml(q.correct_answer);
        const options = [...q.incorrect_answers.map(decodeHtml), correct_answer];
        // Shuffle options
        for (let i = options.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [options[i], options[j]] = [options[j], options[i]];
        }
        return { question, correct_answer, options };
      });
    }
  } catch (e) {
    // Fail silently, no UI message
    console.error('Fetch error:', e);
  }
}

// Show 20 questions randomly from cached batch, no repeats until all shown
function show20Questions(topic) {
  const quizArea = document.getElementById('quiz-area');
  quizArea.innerHTML = '';

  const batch = questionsBatch[topic];
  if (!batch.length) {
    // Batch not fetched yet - try fetch silently, show empty for now
    fetch100Questions(topic);
    return;
  }

  const shownSet = shownIndexes[topic];

  // Get 20 unique random indexes from batch that are not in shownSet
  let availableIndexes = [];
  for (let i = 0; i < batch.length; i++) {
    if (!shownSet.has(i)) availableIndexes.push(i);
  }

  // If less than 20 left, reset shownSet to allow repeats
  if (availableIndexes.length < 20) {
    shownSet.clear();
    availableIndexes = [...Array(batch.length).keys()];
  }

  // Shuffle availableIndexes and pick 20
  for (let i = availableIndexes.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [availableIndexes[i], availableIndexes[j]] = [availableIndexes[j], availableIndexes[i]];
  }
  const selectedIndexes = availableIndexes.slice(0, 20);

  selectedIndexes.forEach(idx => {
    shownSet.add(idx);
    const q = batch[idx];

    const block = document.createElement('div');
    block.className = 'question-block';

    const qText = document.createElement('div');
    qText.className = 'question-text';
    qText.textContent = q.question;
    block.appendChild(qText);

    const optsDiv = document.createElement('div');
    optsDiv.className = 'options';
    q.options.forEach(opt => {
      const optElem = document.createElement('div');
      optElem.className = 'option';
      optElem.textContent = opt;
      optsDiv.appendChild(optElem);
    });
    block.appendChild(optsDiv);

    const answerDiv = document.createElement('div');
    answerDiv.className = 'correct-answer';
    answerDiv.textContent = `Answer: ${q.correct_answer}`;
    block.appendChild(answerDiv);

    quizArea.appendChild(block);
  });
}

// On button click: fetch 100 questions silently if not fetched, then show 20 questions
async function onTopicClick(topic) {
  if (questionsBatch[topic].length < 100) {
    await fetch100Questions(topic);
  }
  show20Questions(topic);
}

// Attach event listeners
document.getElementById('webdev-btn').onclick = () => onTopicClick('webdev');
document.getElementById('cloud-btn').onclick = () => onTopicClick('cloud');
document.getElementById('cyber-btn').onclick = () => onTopicClick('cyber');
</script>

</body>
</html>
